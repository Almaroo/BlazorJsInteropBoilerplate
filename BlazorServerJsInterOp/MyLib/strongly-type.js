const path = require('path');
const fs = require('fs');

class StronglyTypedCSharpFileBuilder {
    #namespace;
    #fileName;
    #libraryName;
    #methods;
    #outputFileName;
    
    constructor() {
        this.namespace = '';
        this.fileName = '';
        this.outputFileName = '';
        this.libraryName = '';
        this.methods = [];
    }
    
    withNamespace(namespace) {
        if (namespace && typeof namespace !== 'string') throw new Error('namespace must be string and cannot be null or empty');
        this.namespace = namespace;
    }
    
    withFileName(fileName) {
        if (fileName && typeof fileName !== 'string') throw new Error('fileName must be string cannot be null or empty');
        this.fileName = fileName;
    }

    withOutputFileName(outputFileName) {
        if (fileName && typeof fileName !== 'string') throw new Error('outputFileName must be string cannot be null or empty');
        this.outputFileName = outputFileName;
    }
    
    withLibraryName(libraryName) {
        if (libraryName && typeof libraryName !== 'string') throw new Error('libraryName must be string cannot be null or empty');
        this.libraryName = libraryName;
    }
    
    withMethod(methodName) {
        if (typeof methodName !== 'string') throw new Error('methodName must be string and cannot be null or empty');
        this.methods.push(methodName);
    }
    
    build() {
        if (!this.fileName || !this.libraryName || !this.namespace) throw new Error('not all values were set');
        return `//this file is autogenerated by strongly-type script, any manual changes will be overriden on next build
namespace ${namespace}.${fileName}
{
    public static class ${fileName} 
    {
        public static string FileName => "${this.outputFileName}";
        public static string LibraryName => "${this.libraryName}";
        
        public static class Methods
        {
            ${this.methods.map(method => `public static string ${method} = "${method}";`).join('\n\t\t\t')}
        }
    }
}
`
    }
}

const namespace = path.basename(path.dirname(__dirname));
const fileName = path.basename(__dirname);

const configPath = path.resolve(__dirname, './webpack.config.js');
const libraryNameRegEx = /libraryName = "(?<libraryName>[a-zA-Z]+)"/;
const outputFileRegEx = /fileName = "(?<fileName>[a-zA-Z._]+)"/;
const configData = fs.readFileSync(configPath, 'utf8', (err) => {
    if (err) throw err;
});
const libraryName = configData.match(libraryNameRegEx).groups['libraryName'];
const outputFileName = configData.match(outputFileRegEx).groups['fileName'];

const indexPath = path.resolve(__dirname, './src/index.js');
const methodRegEx = /export function (?<methodName>[a-zA-Z]+)\(\w*\)/g;
const indexData = fs.readFileSync(indexPath, 'utf8', (err) => {
    if (err) throw err;
});
const methodNames = indexData.matchAll(methodRegEx);

const builder = new StronglyTypedCSharpFileBuilder();

builder.withFileName(fileName);
builder.withLibraryName(libraryName);
builder.withNamespace(namespace);
builder.withOutputFileName(outputFileName);

for (const methodName of methodNames) {
    builder.withMethod(methodName.groups['methodName']);
}

fs.writeFileSync(path.resolve(__dirname, `./${fileName}.cs`), builder.build(), (err) => {
    if (err) throw err;
})
